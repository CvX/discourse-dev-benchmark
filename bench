#!/usr/bin/env ruby
# frozen_string_literal: true

require 'socket'
require 'fileutils'
require 'etc'

# https://stackoverflow.com/questions/7749568/how-can-i-do-standard-deviation-in-ruby
module Enumerable

  def sum
    self.inject(0) { |accum, i| accum + i }
  end

  def mean
    self.sum / self.length.to_f
  end

  def sample_variance
    m = self.mean
    sum = self.inject(0) { |accum, i| accum + (i - m)**2 }
    sum / (self.length - 1).to_f
  end

  def standard_deviation
    Math.sqrt(self.sample_variance)
  end

end

class DevBench

  PATH = File.expand_path('..', __FILE__)
  PG_PATH = "#{PATH}/data/pg"
  PG_CONF = "#{PG_PATH}/postgresql.conf"
  PG_SOCK_PATH = "#{PG_PATH}/sockets"
  DB_DUMP = "#{PATH}/data/db.dump"
  REDIS_PATH = "#{PATH}/data/redis"
  REDIS_CONF = "#{PATH}/data/redis/redis.conf"

  def port_available?(port)
    TCPServer.open(port).close
    true
  rescue Errno::EADDRINUSE
    false
  end

  def find_free_port(range)
    range.each do |port|
      return port if port_available?(port)
    end
  end

  def pg_port
    @pg_port ||= find_free_port(11000..11900)
  end

  def redis_port
    @redis_port ||= find_free_port(12000..12900)
  end

  def redis_pid
    @redis_pid
  end

  def set_redis_pid(pid)
    @redis_pid = pid
  end

  def start_postgres
    FileUtils.rm_rf PG_PATH
    `initdb -D '#{PG_PATH}' --auth-host=trust --locale=en_US.UTF-8 -E UTF8 2> /dev/null`

    FileUtils.mkdir PG_SOCK_PATH
    conf = File.read(PG_CONF)
    File.write(PG_CONF, conf + "\nport = #{pg_port}\nunix_socket_directories = '#{PG_SOCK_PATH}'")

    puts "Starting postgres on port: #{pg_port}"
    ENV['DISCOURSE_PG_PORT'] = pg_port.to_s

    Thread.new do
      `pg_ctl -D '#{PG_PATH}' start`
    end

    puts "Waiting for PG server to start..."
    while !`pg_ctl -D '#{PG_PATH}' status`.include?('server is running')
      sleep 0.1
    end

    `createdb -h localhost -p #{pg_port} discourse_development`
    `psql -h localhost -p #{pg_port} discourse_development < '#{DB_DUMP}'`

    puts "PG server is ready and DB is loaded"
  end

  def stop_redis
    # print "Stopping redis #{redis_pid} ..."
    Process.kill('QUIT', redis_pid)
    Process.waitpid(redis_pid)
    # puts " stopped"
  end

  def start_redis
    `rm -fr '#{REDIS_PATH}/dump.rdb'`
    set_redis_pid(
      Process.spawn(
        "redis-server",
        REDIS_CONF,
        '--port',
        redis_port.to_s,
        '--dir',
        REDIS_PATH,
        out: '/dev/null'
      )
    )
    ENV['DISCOURSE_REDIS_PORT'] = redis_port.to_s

    puts "Redis server is started in pid #{redis_pid} port: #{redis_port}"
  end

  def measure(iterations: 10, warmup: 4, min_duration: 10)
    iterations += warmup

    total_duration = 0

    durations = []

    while (iterations > 0 || min_duration > total_duration)
      start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      yield
      finish = Process.clock_gettime(Process::CLOCK_MONOTONIC)

      durations << finish - start if (warmup -= 1) < 0
      total_duration += finish - start
      iterations -= 1
    end

    [durations.mean, durations.standard_deviation]
  end

  def measure_in_fork(threads: 1, iterations: 10, warmup: 2, min_duration: 3)
    means = []
    deviations = []

    (1..threads).map do
      Thread.new do
        r, w = IO.pipe

        pid = fork do
          require File.expand_path('../config/environment', __FILE__)
          mean, deviation = measure(iterations: iterations, warmup: 2) do
            yield
          end
          r.close
          w.puts mean.to_s
          w.puts deviation.to_s
        end

        w.close

        Process.wait pid

        mean, deviation = r.read.split("\n")

        r.close

        means << mean.to_f
        deviations << deviation.to_f
      end
    end.each(&:join)

    [means.mean / threads.to_f, deviations.mean / threads.to_f]
  end

  def format(desc, result)
    mean, deviation = result
    per_sec = 1.0 / mean

    percent = (deviation / mean) * 100

    if mean > 0.9
      puts "#{desc}: #{mean.round(3)} (±#{percent.round(1)}%) seconds"
    else
      puts "#{desc}: #{per_sec.round(3)} (±#{percent.round(1)}%) op/s"
    end
  end

  def topic_title
  end

  def post_body
    <<~TEXT
      I am some random post body, **I have some bold**

      I have some lines

      And I have the this in it #{SecureRandom.hex}
    TEXT
  end

  def run_tests(threads = 1)
    puts
    puts "Running benchmark on #{threads} core#{threads > 1 ? "s" : "" }"
    puts "-" * 20
    puts

    result = measure_in_fork(threads: threads) do
      req = {
        "REQUEST_METHOD" => "GET",
        "SCRIPT_NAME" => "",
        "PATH_INFO" => "/t/this-is-an-amazing-first-topic/11",
        "QUERY_STRING" => "",
        "SERVER_NAME" => "127.0.0.1",
        "SERVER_PORT" => "80",
        "REQUEST_PATH" => "/",
        "REMOTE_ADDR" => "127.0.0.1",
        "HTTP_VERSION" => "HTTP/1.0",
        "rack.input" => StringIO.new(""),
        "rack.version" => [1, 2],
        "rack.url_scheme" => "http"
      }

      Rails.application.call(req)
    end

    format("Topic View (dev)", result)

    if threads == 1
      # not a good test to run cause of internal locking
      result = measure_in_fork(threads: threads) do
        Jobs.run_immediately!

        PostCreator.create(
          Discourse.system_user,
          raw: post_body,
          title: "I am a title #{SecureRandom.hex}",
          skip_validations: true
        )
      end

      format("Topic Creation Time - no background queue", result)
    end

    result = measure_in_fork(threads: threads, iterations: 100) do
      Pbkdf2.hash_password(SecureRandom.hex, SecureRandom.hex, 64000, "sha256")
    end

    format("PBKdf2 64000 sha256", result)

    readme = File.read("README.md")
    result = measure_in_fork(threads: threads) do
      PrettyText.cook(readme)
    end

    format("Cooking README.md", result)

    result = measure_in_fork(threads: threads) do
      `bin/rails r Post.first`
    end

    format("Booting Rails", result)
  end

  def about
    begin
      require 'facter'
    rescue LoadError
      puts "Installing facter to gather system info, please re-run"
      `gem install facter`
      exit
    end

    Facter::Util::Config.external_facts_dirs = []
    facts = Facter.to_hash

    cores = Etc.nprocessors
    facts.delete_if { |k, v|
      !["operatingsystem", "architecture", "kernelversion",
      "memorysize", "physicalprocessorcount", "processor0",
      "virtual"].include?(k)
    }

    puts
    puts
    puts "System Info"
    puts "-" * 20

    facts.each do |k, v|
      puts "#{k}: #{v}"
    end
    puts "cores: #{cores}"
    puts "ruby: #{RUBY_VERSION}"
    puts `pg_ctl --version`
    puts `redis-server --version`

    puts
  end

  def stop_postgres
    `pg_ctl -D '#{PG_PATH}' stop`
  end

  def test_it
    start_redis
    start_postgres

    run_tests
    run_tests(Etc.nprocessors)

    about
  ensure
    stop_redis
    stop_postgres
  end
end

DevBench.new.test_it
