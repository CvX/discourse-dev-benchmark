#!/usr/bin/env ruby
# frozen_string_literal: true

require 'socket'
require 'fileutils'

# https://stackoverflow.com/questions/7749568/how-can-i-do-standard-deviation-in-ruby
module Enumerable

  def sum
    self.inject(0) { |accum, i| accum + i }
  end

  def mean
    self.sum / self.length.to_f
  end

  def sample_variance
    m = self.mean
    sum = self.inject(0) { |accum, i| accum + (i - m)**2 }
    sum / (self.length - 1).to_f
  end

  def standard_deviation
    Math.sqrt(self.sample_variance)
  end

end

PATH = File.expand_path('..', __FILE__)
PG_PATH = "#{PATH}/data/pg"
PG_CONF = "#{PG_PATH}/postgresql.conf"
PG_SOCK_PATH = "#{PG_PATH}/sockets"
DB_DUMP = "#{PATH}/data/db.dump"
REDIS_PATH = "#{PATH}/data/redis"
REDIS_CONF = "#{PATH}/data/redis/redis.conf"

def port_available?(port)
  TCPServer.open(port).close
  true
rescue Errno::EADDRINUSE
  false
end

def find_free_port(range)
  range.each do |port|
    return port if port_available?(port)
  end
end

def pg_port
  @pg_port ||= find_free_port(11000..11900)
end

def redis_port
  @redis_port ||= find_free_port(12000..12900)
end

def redis_pid
  @redis_pid
end

def set_redis_pid(pid)
  @redis_pid = pid
end

def start_postgres
  FileUtils.rm_rf PG_PATH
  `initdb -D '#{PG_PATH}' --auth-host=trust --locale=en_US.UTF-8 -E UTF8 2> /dev/null`

  FileUtils.mkdir PG_SOCK_PATH
  conf = File.read(PG_CONF)
  File.write(PG_CONF, conf + "\nport = #{pg_port}\nunix_socket_directories = '#{PG_SOCK_PATH}'")

  puts "Starting postgres on port: #{pg_port}"
  ENV['DISCOURSE_PG_PORT'] = pg_port.to_s

  Thread.new do
    `pg_ctl -D '#{PG_PATH}' start`
  end

  puts "Waiting for PG server to start..."
  while !`pg_ctl -D '#{PG_PATH}' status`.include?('server is running')
    sleep 0.1
  end

  `createdb -h localhost -p #{pg_port} discourse_development`
  `psql -h localhost -p #{pg_port} discourse_development < '#{DB_DUMP}'`

  puts "PG server is ready and DB is loaded"
end

def stop_redis
  # print "Stopping redis #{redis_pid} ..."
  Process.kill('QUIT', redis_pid)
  Process.waitpid(redis_pid)
  # puts " stopped"
end

def start_redis
  `rm -fr '#{REDIS_PATH}/dump.rdb'`
  set_redis_pid(
    Process.spawn(
      "redis-server",
      REDIS_CONF,
      '--port',
      redis_port.to_s,
      '--dir',
      REDIS_PATH,
      out: '/dev/null'
    )
  )
  ENV['DISCOURSE_REDIS_PORT'] = redis_port.to_s

  puts "Redis server is started in pid #{redis_pid} port: #{redis_port}"
end

def measure(iterations: 10, warmup: 2, min_duration: 3)
  iterations += warmup

  total_duration = 0

  durations = []

  while (iterations > 0 || min_duration > total_duration)
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    yield
    finish = Process.clock_gettime(Process::CLOCK_MONOTONIC)

    durations << finish - start if (warmup -= 1) < 0
    total_duration += finish - start
    iterations -= 1
  end

  [durations.mean, durations.standard_deviation]
end

def measure_in_fork(iterations: 10, warmup: 2, min_duration: 3)
  r, w = IO.pipe

  pid = fork do
    require File.expand_path('../config/environment', __FILE__)
    mean, deviation = measure(iterations: iterations, warmup: 2) do
      yield
    end
    r.close
    w.puts mean.to_s
    w.puts deviation.to_s
  end

  w.close

  Process.wait pid

  mean, deviation = r.read.split("\n")

  r.close

  [mean.to_f, deviation.to_f]
end

def format(desc, result)
  mean, deviation = result
  per_sec = 1.0 / mean

  percent = (deviation / mean) * 100

  if mean > 0.9
    puts "#{desc}: #{mean.round(3)} (±#{percent.round(1)}%) seconds"
  else
    puts "#{desc}: #{per_sec.round(3)} (±#{percent.round(1)}%) op/s"
  end
end

def topic_title
end

def post_body
  <<~TEXT
    I am some random post body, **I have some bold**

    I have some lines

    And I have the this in it #{SecureRandom.hex}
  TEXT
end

def single_thread_tests
  puts
  puts "Single thread tests"
  puts "-" * 20
  puts

  result = measure_in_fork do
    Jobs.run_immediately!

    PostCreator.create(
      Discourse.system_user,
      raw: post_body,
      title: "I am a title #{SecureRandom.hex}",
      skip_validations: true
    )
  end

  format("Topic Creation Time - no background queue", result)

  readme = File.read("README.md")
  result = measure_in_fork do
    PrettyText.cook(readme)
  end

  format("Cooking README.md", result)

  result = measure do
    `bin/rails r Post.first`
  end

  format("Booting Rails", result)
end

def stop_postgres
  `pg_ctl -D '#{PG_PATH}' stop`
end

begin
  start_redis
  start_postgres

  single_thread_tests
ensure
  stop_redis
  stop_postgres
end
