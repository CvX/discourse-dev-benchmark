#!/usr/bin/env ruby
# frozen_string_literal: true

require 'socket'
require 'fileutils'

PATH = File.expand_path('..', __FILE__)
PG_PATH = "#{PATH}/data/pg"
PG_CONF = "#{PG_PATH}/postgresql.conf"
PG_SOCK_PATH = "#{PG_PATH}/sockets"
DB_DUMP = "#{PATH}/data/db.dump"

def port_available?(port)
  TCPServer.open(port).close
  true
rescue Errno::EADDRINUSE
  false
end

def find_free_port(range)
  range.each do |port|
    return port if port_available?(port)
  end
end

def pg_port
  @pg_port ||= find_free_port(11000..11900)
end

def start_postgres
  FileUtils.rm_rf PG_PATH
  `initdb -D '#{PG_PATH}' --auth-host=trust --locale=en_US.UTF-8 -E UTF8 2> /dev/null`

  FileUtils.mkdir PG_SOCK_PATH
  conf = File.read(PG_CONF)
  File.write(PG_CONF, conf + "\nport = #{pg_port}\nunix_socket_directories = '#{PG_SOCK_PATH}'")

  puts "Starting postgres on port: #{pg_port}"
  ENV['DISCOURSE_PORT'] = pg_port.to_s

  Thread.new do
    `pg_ctl -D '#{PG_PATH}' start`
  end

  puts "Waiting for PG server to start..."
  while !`pg_ctl -D '#{PG_PATH}' status`.include?('server is running')
    sleep 0.1
  end

  `createdb -h localhost -p #{pg_port} discourse_development`
  `psql -h localhost -p #{pg_port} discourse_development < '#{DB_DUMP}'`

  puts "PG server is ready and DB is loaded"
end

def measure(command, iterations)
  # throw away slowest and fastest
  iterations += 2

  durations = []
  iterations.times do
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    `#{command}`
    finish = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    durations << finish - start
  end

  durations.sort!
  durations = durations[1..-2]

  puts "#{durations.sum / durations.length.to_f}"
end

def single_thread_tests
  measure('bin/rails r Post.first', 10)
end

def stop_postgres
  `pg_ctl -D '#{PG_PATH}' stop`
end

begin
  start_postgres

  single_thread_tests
ensure
  stop_postgres
end
